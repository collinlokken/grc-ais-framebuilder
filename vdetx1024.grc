options:
  parameters:
    author: ''
    category: '[GRC Hier Blocks]'
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: VDETERframebuilder
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: Not titled yet
    window_size: (1000,1000)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 8]
    rotation: 0
    state: enabled

blocks:
- name: bit_rate
  id: variable
  parameters:
    comment: ''
    value: 57.6e3
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [568, 20.0]
    rotation: 0
    state: true
- name: qpsk_vde_ter_pi4
  id: variable_constellation
  parameters:
    comment: ''
    const_points: '[-0.7071 -0.7071j, -1+0j,-0.7071+0.7071j,0+1j,0.7071-0.7071j, 0-1j,0.7071+0.7071j,1+0j]'
    dims: '1'
    precision: '8'
    rot_sym: '8'
    soft_dec_lut: None
    sym_map: '[0, 1, 2, 3, 4, 5, 6, 7]'
    type: calcdist
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [304, 12.0]
    rotation: 0
    state: enabled
- name: samp_rate
  id: variable
  parameters:
    comment: ''
    value: '1105920'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [184, 12]
    rotation: 0
    state: enabled
- name: analog_sig_source_x_0
  id: analog_sig_source_x
  parameters:
    affinity: ''
    alias: ''
    amp: '1'
    comment: ''
    freq: -25e3
    maxoutbuf: '0'
    minoutbuf: '0'
    offset: '0'
    phase: '0'
    samp_rate: samp_rate
    type: complex
    waveform: analog.GR_SIN_WAVE
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [520, 132.0]
    rotation: 0
    state: enabled
- name: analog_sig_source_x_0_0
  id: analog_sig_source_x
  parameters:
    affinity: ''
    alias: ''
    amp: '1'
    comment: ''
    freq: +25e3
    maxoutbuf: '0'
    minoutbuf: '0'
    offset: '0'
    phase: '0'
    samp_rate: samp_rate
    type: complex
    waveform: analog.GR_SIN_WAVE
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [512, 468.0]
    rotation: 0
    state: disabled
- name: blocks_multiply_const_xx_0
  id: blocks_multiply_const_xx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    const: '900'
    maxoutbuf: '0'
    minoutbuf: '0'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [984, 444.0]
    rotation: 0
    state: enabled
- name: blocks_multiply_const_xx_0_0
  id: blocks_multiply_const_xx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    const: '900'
    maxoutbuf: '0'
    minoutbuf: '0'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [968, 548.0]
    rotation: 0
    state: disabled
- name: blocks_multiply_xx_0
  id: blocks_multiply_xx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_inputs: '2'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [848, 368.0]
    rotation: 0
    state: enabled
- name: blocks_multiply_xx_0_2
  id: blocks_multiply_xx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    num_inputs: '2'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [832, 520.0]
    rotation: 0
    state: disabled
- name: blocks_selector_0
  id: blocks_selector
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    enabled: 'True'
    input_index: '0'
    maxoutbuf: '0'
    minoutbuf: '0'
    num_inputs: '2'
    num_outputs: '1'
    output_index: '0'
    showports: 'True'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1176, 484.0]
    rotation: 0
    state: disabled
- name: blocks_throttle_0
  id: blocks_throttle
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    ignoretag: 'True'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_second: samp_rate
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [800, 172.0]
    rotation: 0
    state: enabled
- name: digital_constellation_modulator_0
  id: digital_constellation_modulator
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    constellation: qpsk_vde_ter_pi4
    differential: 'True'
    excess_bw: '0.3'
    log: 'False'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_symbol: int(samp_rate/bit_rate)
    verbose: 'True'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [304, 268.0]
    rotation: 0
    state: enabled
- name: epy_block_0
  id: epy_block
  parameters:
    LinkID: '5'
    VDEMessage: '''0101000000001110101101111001101000101010011101011011110011010001011000100000000000000000001100100'''
    _source_code: "\"\"\"\nEmbedded Python Blocks:\n\nEach time this file is saved,\
      \ GRC will instantiate the first class it finds\nto get ports and parameters\
      \ of your block. The arguments to __init__  will\nbe the parameters. All of\
      \ them are required to have default values!\n\"\"\"\n\nimport numpy as np\n\
      from gnuradio import gr\nimport time\n\n\nclass blk(gr.sync_block):  # other\
      \ base classes are basic_block, decim_block, interp_block\n    \"\"\"Embedded\
      \ Python Block\"\"\"\n\n    def __init__(self, LinkID=11, VDEMessage='0101000000001110101101111001101000101010011101011011110011010001011000100000000000000000001100100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'):\
      \  # only default arguments here\n        \"\"\"arguments to this function show\
      \ up as parameters in GRC\"\"\"\n        gr.sync_block.__init__(\n         \
      \   self,\n            name='VDE-TER Framebuilder',   # will show up in GRC\n\
      \            in_sig=None,\n            out_sig=[np.byte]\n        )\n      \
      \  # if an attribute with the same name as a parameter is found,\n        #\
      \ a callback is registered (properties work, too).\n        #self.example_param\
      \ = example_param\n\n        self.VDEMessage = VDEMessage\n        self.LinkID\
      \ = LinkID \n        '''Link ID should only be 11, 17, 19. 5 is only included,\
      \ because we could not find\n        examples of any other link ID frame generation.\
      \ In order to validate the code, it was \n        neccessary to include link\
      \ ID 5, the code also consists of modulation, so if link ID 19 \n        is\
      \ used, the code does not work, according to the technical specifications in\
      \ ITU'''\n    \n    linkID_datagram_length = {11: 400, 17: 1840, 19: 5584, 5:256}\
      \ #Datagram length that was determined by subtracting 32 from the FEC input\n\
      \    \n\n    def append_padding(self, LinkID, message, linkID_datagram_length):\n\
      \        #only take account for messages shorter then the datagram. Fragmentation\
      \ is not taken into account\n        datagram_length = linkID_datagram_length[LinkID]\n\
      \        if datagram_length != len(message):\n            message = message\
      \ + '0'*(datagram_length-len(message))\n        return message\n    \n    #table\
      \ and crc32 code from https://gist.github.com/Miliox/b86b60b9755faf3bd7cf\n\
      \    CRC32_MPEG_TABLE = [\n        0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,\n\
      \      0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,\n      0x2608edb8, 0x22c9f00f,\
      \ 0x2f8ad6d6, 0x2b4bcb61,\n      0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,\n\
      \      0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,\n      0x5f15adac, 0x5bd4b01b,\
      \ 0x569796c2, 0x52568b75,\n      0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,\n\
      \      0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,\n      0x9823b6e0, 0x9ce2ab57,\
      \ 0x91a18d8e, 0x95609039,\n      0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,\n\
      \      0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,\n      0xad2f2d84, 0xa9ee3033,\
      \ 0xa4ad16ea, 0xa06c0b5d,\n      0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,\n\
      \      0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,\n      0xf23a8028, 0xf6fb9d9f,\
      \ 0xfbb8bb46, 0xff79a6f1,\n      0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,\n\
      \      0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,\n      0x278206ab, 0x23431b1c,\
      \ 0x2e003dc5, 0x2ac12072,\n      0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,\n\
      \      0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,\n      0x7897ab07, 0x7c56b6b0,\
      \ 0x71159069, 0x75d48dde,\n      0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,\n\
      \      0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,\n      0x4d9b3063, 0x495a2dd4,\
      \ 0x44190b0d, 0x40d816ba,\n      0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,\n\
      \      0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,\n      0x8aad2b2f, 0x8e6c3698,\
      \ 0x832f1041, 0x87ee0df6,\n      0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,\n\
      \      0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,\n      0xf3b06b3b, 0xf771768c,\
      \ 0xfa325055, 0xfef34de2,\n      0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,\n\
      \      0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,\n      0x690ce0ee, 0x6dcdfd59,\
      \ 0x608edb80, 0x644fc637,\n      0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,\n\
      \      0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,\n      0x5c007b8a, 0x58c1663d,\
      \ 0x558240e4, 0x51435d53,\n      0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,\n\
      \      0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,\n      0x0315d626, 0x07d4cb91,\
      \ 0x0a97ed48, 0x0e56f0ff,\n      0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,\n\
      \      0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,\n      0xe22b20d2, 0xe6ea3d65,\
      \ 0xeba91bbc, 0xef68060b,\n      0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,\n\
      \      0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,\n      0xbd3e8d7e, 0xb9ff90c9,\
      \ 0xb4bcb610, 0xb07daba7,\n      0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,\n\
      \      0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,\n      0x8832161a, 0x8cf30bad,\
      \ 0x81b02d74, 0x857130c3,\n      0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,\n\
      \      0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,\n      0x7b827d21, 0x7f436096,\
      \ 0x7200464f, 0x76c15bf8,\n      0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,\n\
      \      0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,\n      0x029f3d35, 0x065e2082,\
      \ 0x0b1d065b, 0x0fdc1bec,\n      0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,\n\
      \      0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,\n      0xc5a92679, 0xc1683bce,\
      \ 0xcc2b1d17, 0xc8ea00a0,\n      0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,\n\
      \      0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,\n      0xf0a5bd1d, 0xf464a0aa,\
      \ 0xf9278673, 0xfde69bc4,\n      0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,\n\
      \      0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,\n      0xafb010b1, 0xab710d06,\
      \ 0xa6322bdf, 0xa2f33668,\n      0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4\n\
      \        ]\n    \n    def _crc32(self, data, CRC32_MPEG_TABLE, crc=0xFFFFFFFF):\n\
      \n        table = CRC32_MPEG_TABLE\n        for byte in data: \n           \
      \ crc = (crc << 8) ^ table[((crc >> 24) ^ byte) & 0xFF]\n        \n        #Take\
      \ last 32 bits of the value \n        crc = (crc & 0xFFFFFFFF)\n        \n \
      \       #turn into binary\n        #crc = format(crc, 'b') wrong\n        crc\
      \ = '{0:b}'.format(crc).rjust(32,'0') #use to append 0 padding at the start\n\
      \        return crc\n    #Thanks to https://github.com/Michaelangel007/crc32\
      \ for demystifiying crc32\n    #After the payload has been padded and appended\
      \ a crc32 value, turbo encoding need to be done accordingly\n\n    permutation_primes\
      \ = {5: [47,17,233,127,239,139,199,163],\n                          11: [127,191,241,5,83,109,107,179],\n\
      \                          17: [211,61,227,239,181,79,73,193],\n           \
      \               19: [137,101,223,41,67,131,61,47]} #List of permuatationn primes\
      \ associated with a link ID\n    k1_k2 = {5: [2,144],\n             11: [2,216],\n\
      \             17: [6,312],\n             19: [16,351]} #k values associated\
      \ with different link IDs\n\n    def calculate_permutation(self,s, k1, k2, primes):\n\
      \        '''\n        Calculate the permutation numbers for s = (1,...,k)\n\
      \        The operations are from the ITU specification for VDES.\n        '''\n\
      \        m = (s - 1) % 2\n        i = ((s - 1) // (2*k2))\n        j = ((s -\
      \ 1) // 2) - i*k2\n        t = (19*i + 1) % int((k1/2))\n        q = t % 8 +\
      \ 1\n        c = (primes[q-1]*j + 21*m) % k2\n        pi_s = 2*(t + c*k1//2\
      \ + 1) - m\n        return int(pi_s)\n\n    def interleave(self, input, k1,\
      \ k2, primes):\n        #create an empty list to contain the permutated indices\n\
      \        permuted_indices = []\n        #iterate with s values from 1-k, and\
      \ use this to compute the permutated indice\n        for s in range(1,k1*k2+1):\n\
      \            #append the new permutated indices:\n            #indices are from\
      \ 1-k.\n        \n            permuted_indices.append(self.calculate_permutation(s,k1,k2,primes))\n\
      \            #print(s)\n\n        #check for duplicates in permuted indics\n\
      \        if len(set(permuted_indices))!=len(permuted_indices):\n           \
      \ print(\"something is wrong, an duplication exists\")\n    \n        #Generate\
      \ a list of 0 same length as input. \n        interleaved_list = [0] * len(input)\n\
      \        #print(interleaved_list)\n        i = 0\n        for permuted_indice\
      \ in permuted_indices:\n            #s bit read out should be pi(s), so if pi(1)=2\
      \ then input(2) should be the first \n            interleaved_list[i] = input[permuted_indice-1]\n\
      \            i += 1\n        \n        interleaved_string = ''.join(interleaved_list)\n\
      \        \n        return ''.join(interleaved_list)\n\n\n\n    def rsc_encode(self,\
      \ input):\n        '''\n        Contains the Recursive Systematic Convultional\
      \ (RSC) as described in the technical \n        specification of VDES. See https://www.itu.int/dms_pubrec/itu-r/rec/m/R-REC-M.2092-1-202202-I!!PDF-E.pdf,\
      \ \n        Annex 2 for more information\n        '''\n        #Initialize the\
      \ feedback register, should allways start start with 0 in each register\n  \
      \      D = [0, 0, 0]\n        \n\n        #prepare output lists\n        X =\
      \ []\n        Y1 = []\n        Y2 = []\n        xor = 0\n        for bit in\
      \ input:\n            #Compute first xor operations\n            bit = int(bit)\n\
      \            xor = D[2]^D[1]^bit\n\n\n            # Calculate output bits\n\
      \            x = bit\n            y1 = xor ^ D[0] ^ D[2]\n            y2 = \
      \ xor ^ D[0] ^ D[1] ^ D[2]\n\n            #update the feedback register\n  \
      \          D.insert(0, xor)\n            D.pop()\n            #append the output\
      \ bits to the appropriate list\n            X.append(x)\n            Y1.append(y1)\n\
      \            Y2.append(y2)\n        \n        # After all the bits have been\
      \ read in, the next step is to calculate the tail pattern. In this case no bit\
      \ is shifted\n        # in so the encoding need to be changed accordingly. The\
      \ RSC calculates the final string correctly, without the tail bits. \n     \
      \   # The next step is to figure out the corresponding tail bits. After k clocks.\
      \ that is 288 in the test examples, and might\n        # vary depenging on the\
      \ link layer ID. For the 6 subsequent clocks, the switch is moved from position\
      \ A to position B. \n        # This is done to ensure, that the shift register\
      \ contains 3 0's. The tails are then \n        # Appended according to the tail\
      \ puncturing pattern associated with a given link ID. \n\n        #prepare tail\
      \ lists\n        X_tail = []\n        Y1_tail = []\n        Y2_tail = []\n\n\
      \n        #print(D)\n        for i in range(0,3):\n            xor1 = D[1]^D[2]\n\
      \            xor = xor1^xor1\n\n            #compute the output bits for the\
      \ tail\n            x_tail = xor1\n            y1_tail = xor ^ D[0] ^ D[2]\n\
      \            y2_tail =  xor ^ D[0] ^ D[1] ^ D[2]\n            #update the feedback\
      \ register\n            D.insert(0, xor)\n            D.pop()\n            #append\
      \ output bits to the appropriate tail list\n            X_tail.append(x_tail)\n\
      \            Y1_tail.append(y1_tail)\n            Y2_tail.append(y2_tail)\n\n\
      \        #print(D)\n        return X, Y1, Y2, X_tail, Y1_tail, Y2_tail\n   \
      \ \n    puncture_pattern = {5: [[1,0,1,0,0,0], [1,0,0,0,0,0], [1,0,0,0,0,0],\
      \ [1,0,0,0,0,0], [1,0,0,0,0,0], [1,0,0,0,0,1]],\n                        11:\
      \ [[1,1,0,0,0,0], [1,0,0,0,1,0]],\n                        17: [[1,1,0,0,0,0],\
      \ [1,0,0,0,1,0]],\n                        19: [[1,0,1,0,0,0], [1,0,0,0,0,0],\
      \ [1,0,0,0,0,0], [1,0,0,0,0,0], [1,0,0,0,0,0], [1,0,0,0,0,1]]}#puncture pattern\
      \ for the k first clocks for linkIDs\n    \n    puncture_pattern_tail = {5:\
      \ [[1,0,1,0,0,0], [1,0,1,0,0,0], [1,0,0,0,0,0], [0,0,0,1,0,1], [0,0,0,1,0,1],\
      \ [0,0,0,1,0,0]],\n                             11: [[1,1,0,0,0,0], [1,1,0,0,0,0],\
      \ [1,0,0,0,0,0], [0,0,0,1,1,0], [0,0,0,1,1,0], [0,0,0,1,0,0]],\n           \
      \                  17: [[1,1,0,0,0,0], [1,1,0,0,0,0], [1,0,0,0,0,0], [0,0,0,1,1,0],\
      \ [0,0,0,1,1,0], [0,0,0,1,0,0]],\n                             19: [[1,0,1,0,0,0],\
      \ [1,0,1,0,0,0], [1,0,1,0,0,0], [0,0,0,1,0,1], [0,0,0,1,0,1], [0,0,0,1,0,1]]}#puncture\
      \ pattern for the 6 last clocks\n\n    def puncturing(self, puncture_pattern,\
      \ x, y0, y1, x_, y0_, y1_):\n        '''\n        Each RSC encoder produces\
      \ three outputs per input bit. The first encoder produces\n        x,y0,y1 and\
      \ the second x',y0',y1'. The output should then be output if the puncture\n\
      \        pattern contains 1, and be discarded if the puncture pattern is 0.\
      \ The resulting output\n        should be output in the following sequence:\
      \ x,y0,y1,x',y0',y1'.  \n        '''\n        s = \"\"\n        p = 0\n    \
      \    for i in range(len(x)):\n            if puncture_pattern[p][0] == 1:\n\
      \                s += str(x[i])\n            if puncture_pattern[p][1] == 1:\n\
      \                s += str(y0[i])\n            if puncture_pattern[p][2] == 1:\n\
      \                s += str(y1[i])\n            if puncture_pattern[p][3] == 1:\n\
      \                s += str(x_[i])\n            if puncture_pattern[p][4] == 1:\n\
      \                s += str(y0_[i])\n            if puncture_pattern[p][5] ==\
      \ 1:\n                s += str(y1_[i])\n            \n            p+=1\n   \
      \         if p == len(puncture_pattern):\n                p = 0\n\n        return\
      \ s\n\n    def puncturing_tail(self, puncture_pattern, x_tail, y0_tail, y1_tail,\
      \ x_per_tail, y0_per_tail, y1_per_tail):\n        '''\n        After the entire\
      \ input and interleaved string have been encoded and punctured, \n        switch\
      \ in the RSC is switched. For the next three clocks only encoder 1 outputs data.\
      \ \n        For the sequent 3 clocks only the second encoder should output data.\
      \ \n        Depending on the pucnture pattern the first x bits should therefore\
      \ be from encoder 1\n        and the last x bits should be from encoder 2. \n\
      \        '''\n        s = \"\"\n        p = 0\n        test = \"\"\n       \
      \ for i in range(len(x_tail)):\n            if puncture_pattern[p][0] == 1:\n\
      \                s += str(x_tail[i])\n                test = test + 'x'\n  \
      \          if puncture_pattern[p][1] == 1:\n                s += str(y0_tail[i])\n\
      \                test = test + 'y0'\n            if puncture_pattern[p][2] ==\
      \ 1:\n                s += str(y1_tail[i])\n                test = test + 'y1'\n\
      \            p += 1\n            \n            \n        for i in range(len(x_per_tail)):\
      \ \n            if puncture_pattern[p][3] == 1:\n                s += str(x_per_tail[i])\n\
      \                test += \"x'\"\n            if puncture_pattern[p][4] == 1:\n\
      \                s += str(y0_per_tail[i])\n                test += \"y0'\"\n\
      \            if puncture_pattern[p][5] == 1:\n                s += str(y1_per_tail[i])\n\
      \                test += \"y1'\"\n            p += 1\n\n        #print(test)\n\
      \        return s\n    \n    #adapted from https://stackoverflow.com/questions/61229326/is-my-bit-scrambler-implementation-flawed\n\
      \    def bitscrambling(self, input_bits):\n        #Initialize the initialization\
      \ squence according to the ITU specification\n        init_sequence = [1,0,0,1,0,1,0,1,0,0,0,0,0,0,0]\n\
      \n        output_bits = ''\n        for bit in input_bits:\n            input_bit\
      \ = int(bit)\n            \n            #compute the feedback bit by XORing\
      \ the specified bits in the polynomial, namely xor bit 14 and 15 from lfsr\n\
      \            feedback_bit = init_sequence[len(init_sequence)-2]^init_sequence[len(init_sequence)-1]\n\
      \            \n            #Update the initialization sequence, inserting the\
      \ feedback bit at the left\n            init_sequence.pop()\n            init_sequence.insert(0,\
      \ feedback_bit)\n            \n            #XOR the input bit with the feedback\
      \ bit\n            output_bit = input_bit ^ feedback_bit\n            output_bits\
      \ += str(output_bit)\n        \n        return output_bits\n    \n    \n   \
      \ def bitstring_to_bytes(self, bitstring):\n        '''Turn bitstring to bytes\
      \ from the ais frame builder'''\n        result = bytearray()\n\n        for\
      \ i in range(0, len(bitstring), 8):\n            single = int(bitstring[i:i+8],2).to_bytes(1,\
      \ 'big')\n            result = self.append_bytes_together(result, single)\n\n\
      \        return result\n    \n    \n    def append_bytes_together(self, bytes1,\
      \ bytes2):\n        '''Append bytes together from the ais frame builder'''\n\
      \        result = bytearray(bytes1)\n        for byte in bytes2:\n         \
      \   result.append(byte)\n\n        return result\n    \n    #Dictionary containing\
      \ vde-ter identification code for some linkID's\n    \n    linkID_identification_code\
      \ = {5:'11010101111011010111111010111111',\n                               \
      \   11:'11101101001011101100001001111100',\n                               \
      \   17:'10000111001101110010010011100101',\n                               \
      \   19:'10001111010010000010010000011010'}\n                               \
      \   \n    linkID_reverse = {11:'10110111011101000100001100111110',\n       \
      \               17:'11100001111011000010010010100111',\n                   \
      \   19:'11110001000100100010010001011000'}\n    \n    mapping_purple = {'00':\
      \ [-1,0],\n                  '01': [0,1],\n                  '10': [0,-1],\n\
      \                  '11':[1,0]}#QPSK mapping from the ITU, purple points\n  \
      \  \n    mapping_green = {'11': [0.7,0.7],\n                 '01': [-0.7,0.7],\n\
      \                 '00': [-0.7, -0.7],\n                 '10': [0.7, -0.7]}#QPSK\
      \ mapping from ITU, green points\n    \n    \n    def compute_mapping_bytes(self,final):\n\
      \        \n        tmp = \"\"\n        x = 0\n        mapping = []\n       \
      \ for i in range(0,len(final)-1,2): #For every 2 bit\n            #append the\
      \ second bit\n            tmp = final[i]+final[i+1]\n            if x%2 == 0:\n\
      \                #map every even bit index to green\n                mapping.append(self.mapping_green[tmp])\n\
      \            else: \n                #map every odd bit index to purple\n  \
      \              mapping.append(self.mapping_purple[tmp])\n            x+= 1\n\
      \        \n            \n        return mapping\n    \n    \n    def bytes_to_bitstring(self,\
      \ bytes):\n        #turn byte to bitstring form ais framebuilder\n        return\
      \ bin(int.from_bytes(bytes, 'big'))[2:].rjust(len(bytes)*8,'0')\n        \n\
      \        \n    def reverse_bit_order(self, bytes):\n        #Reverse the bit\
      \ order for a byte to ensure correct endiannes, from ais framebuilder\n    \
      \    bitstring = self.bytes_to_bitstring(bytes)\n\n        for i in range(0,len(bitstring),8):\n\
      \            block = bitstring[i:i+8]\n            bitstring = bitstring[:i]\
      \ + block[::-1] + bitstring[i+8:]\n\n        return bitstring\n            \
      \                   \n    \n    def build_frame(self):\n        #Syncword sequence\
      \ for asm-ter and vde-ter\n        syncword = '111111001101010000011001010'\n\
      \        #1 maps to (1 1)\n        #0 maps to (0,0)\n        linkID_code = self.linkID_identification_code[self.LinkID]\n\
      \n        #append padding according to the linkID datagram length\n        padded_input\
      \ = self.append_padding(self.LinkID, self.VDEMessage, self.linkID_datagram_length)\n\
      \        \n        #compute crc\n        \n        \n        int_payload = int(padded_input,2)\n\
      \t\n        byte_payload = int_payload.to_bytes(len(padded_input)//8, 'big')\n\
      \n        crc = self._crc32(byte_payload, self.CRC32_MPEG_TABLE)\n\n       \
      \ #append crc\n        \n        payload_crc = padded_input + crc\n        \n\
      \        #If linkID, 11, 17 or 19, apply endianess\n        \n        if self.LinkID\
      \ != 5:\n            #turn bitstring into bytes\n            int_payload = int(payload_crc,2)\n\
      \            byte_payload = int_payload.to_bytes(len(payload_crc)//8,'big')\n\
      \            \n            #reverse the bit order of the byte\n            payload_crc\
      \ = self.reverse_bit_order(byte_payload)\n            #append the reverse bit\
      \ order for each byte for syncword and link ID\n            syncword = '001111110010101110011000010'\
      \ \n            linkID_code = self.linkID_reverse[self.LinkID]\n        \n \
      \       \n        \n\n        #rearrange the input, according to the link ID\
      \ parameters\n\n        rearranged_input = self.interleave(payload_crc, self.k1_k2[self.LinkID][0],\
      \ self.k1_k2[self.LinkID][1],self.permutation_primes[self.LinkID])\n\n     \
      \   #Compute the output for the RSC encoder, for the payload_crc and rearranged\
      \ input\n\n        x, y0, y1, x_tail, y0_tail, y1_tail  = self.rsc_encode(payload_crc)\n\
      \n        x_per, y0_per, y1_per, x_per_tail, y0_per_tail, y1_per_tail = self.rsc_encode(rearranged_input)\
      \  \n\n        #compute the output data, using the puncturing pattern\n\n  \
      \      turbo_encoded_output = self.puncturing(self.puncture_pattern[self.LinkID],\
      \ x, y0, y1, x_per, y0_per, y1_per)\n        \n        #print(turbo_encoded_output==\"\
      001010000000000010110101111011111000110010000101110100111010101111011110010110100000101010000101000000000100000101000001101001000100000100000000000000010100000001000000010000000000000001000000000000000000000001000001010000000100000100000001010000010000000100000001010000000100000001000000000000010100000000000001000000010100000101000000010000010011011011100010100000011011011001101011\"\
      )\n\n        #compute the tail bits\n\n        tailbits = self.puncturing_tail(self.puncture_pattern_tail[self.LinkID],\
      \ x_tail, y0_tail, y1_tail, x_per_tail, y0_per_tail, y1_per_tail)\n        \n\
      \        \n\n        #append the tail bits to the turbo encoded output\n\n \
      \       turbo_encoding_done = turbo_encoded_output + tailbits\n\n        #scramble\
      \ the data\n\n        scrambled_data = self.bitscrambling(turbo_encoding_done)\n\
      \        \n\n        syncword_2x = \"\"\n        \n        #double every digit\
      \ in syncword, since 1 maps to qpsk(1 1), and 0 maps to qpsk(0 0)\n        for\
      \ bit in syncword:\n                syncword_2x += 2*(bit)\n               \
      \ \n        \n        final = syncword_2x + linkID_code + scrambled_data\n \
      \       \n        print(scrambled_data)\n        #print(\"done\")\n        \n\
      \        \n        #mapping = self.compute_mapping_bytes(final)\n        \n\
      \        #print(mapping)\n        \n        tmp = \"\"\n        extra_bit =\
      \ \"\" \n        x = 0\n        for i in range(0,len(final)-1,2):\n        \
      \    tmp = final[i]+final[i+1]\n            if x%2 == 0:\n                #mapping.append(mapping_green[tmp])\n\
      \                tmp += \"0\"\n                #print(tmp)\n               \
      \ extra_bit = extra_bit + tmp\n            else:\n                #mapping.append(mapping_purple[tmp])\n\
      \                tmp += \"1\"\n                extra_bit = extra_bit + tmp\n\
      \            x += 1\n\n        #11011111011111011100000111011100011100011100000100000100011111000100011100011100011101001\n\
      \n        #where the syncword bits are 11x or 00x, where x states if it is to\
      \ be mapped to green or purple. \n\n        #linkword and scrambled data is\
      \ 00x, 01x, 10x, 11x,\n\n        #(len(extra_bit)==len(final)*3/2)\n\n     \
      \   \n        \n        #print(mapping)\n        \n\t\n        \n        return\
      \ extra_bit\n\n    \n\n    def work(self, input_items, output_items):\n    \
      \    \n        time.sleep(1)\n\n        final_frame = self.build_frame()\n \
      \       \n        final_frame = [k for k in self.bitstring_to_bytes(final_frame)]\n\
      \        \n        print(final_frame)\n\n\n        if len(output_items[0]) >=\
      \ len(final_frame):\n        \n            for i in range(len(final_frame)):\n\
      \                output_items[0][i] = final_frame[i]\n            \n       \
      \     output_length = len(final_frame)\n            \n        else:\n      \
      \      output_length = 0\n        \n        return output_length\n\n\n\n   \
      \     \n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('VDE-TER Framebuilder', 'blk', [('LinkID', '11'), ('VDEMessage', "'0101000000001110101101111001101000101010011101011011110011010001011000100000000000000000001100100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000'")],
      [], [('0', 'byte', 1)], 'Embedded Python Block', ['LinkID', 'VDEMessage'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [32, 260.0]
    rotation: 0
    state: true
- name: epy_block_1
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Blocks:\n\nEach time this file is saved,\
      \ GRC will instantiate the first class it finds\nto get ports and parameters\
      \ of your block. The arguments to __init__  will\nbe the parameters. All of\
      \ them are required to have default values!\n\"\"\"\n\nimport numpy as np\n\
      from gnuradio import gr\n\n\nclass blk(gr.sync_block):  # other base classes\
      \ are basic_block, decim_block, interp_block\n    \"\"\"Embedded Python Block\
      \ example - a simple multiply const\"\"\"\n\n    def __init__(self, example_param=1.0):\
      \  # only default arguments here\n        \"\"\"arguments to this function show\
      \ up as parameters in GRC\"\"\"\n        gr.sync_block.__init__(\n         \
      \   self,\n            name='Embedded Python Block',   # will show up in GRC\n\
      \            in_sig=[np.byte],\n            out_sig=None\n        )\n      \
      \  # if an attribute with the same name as a parameter is found,\n        #\
      \ a callback is registered (properties work, too).\n        self.example_param\
      \ = example_param\n\n    def work(self, input_items, output_items):\n      \
      \  \"\"\"example: multiply with constant\"\"\"\n    \n        \n        return\
      \ 0\n"
    affinity: ''
    alias: ''
    comment: ''
    example_param: '1.0'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Embedded Python Block', 'blk', [('example_param', '1.0')], [('0',
      'byte', 1)], [], 'Embedded Python Block example - a simple multiply const',
      ['example_param'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [256, 436.0]
    rotation: 0
    state: disabled
- name: epy_block_2
  id: epy_block
  parameters:
    _source_code: "\"\"\"\nEmbedded Python Blocks:\n\nEach time this file is saved,\
      \ GRC will instantiate the first class it finds\nto get ports and parameters\
      \ of your block. The arguments to __init__  will\nbe the parameters. All of\
      \ them are required to have default values!\n\"\"\"\n\nimport numpy as np\n\
      from gnuradio import gr\nimport time\n\n\nclass blk(gr.sync_block):  # other\
      \ base classes are basic_block, decim_block, interp_block\n    \"\"\"Embedded\
      \ Python Block example - a simple multiply const\"\"\"\n\n    def __init__(self,\
      \ example_param=1.0):  # only default arguments here\n        \"\"\"arguments\
      \ to this function show up as parameters in GRC\"\"\"\n        gr.sync_block.__init__(\n\
      \            self,\n            name='Embedded Python Block',   # will show\
      \ up in GRC\n            in_sig=[np.complex64],\n            out_sig=None\n\
      \        )\n        # if an attribute with the same name as a parameter is found,\n\
      \        # a callback is registered (properties work, too).\n        self.example_param\
      \ = example_param\n\n    def work(self, input_items, output_items):\n      \
      \  \"\"\"example: multiply with constant\"\"\"\n        test = input_items[0][:]\n\
      \        #output_items[0][:] = input_items[0] * self.example_param\n       \
      \ #print(test)\n        time.sleep(1)\n        return 0\n"
    affinity: ''
    alias: ''
    comment: ''
    example_param: '1.0'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    _io_cache: ('Embedded Python Block', 'blk', [('example_param', '1.0')], [('0',
      'complex', 1)], [], 'Embedded Python Block example - a simple multiply const',
      ['example_param'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [504, 636.0]
    rotation: 0
    state: disabled
- name: osmosdr_sink_0
  id: osmosdr_sink
  parameters:
    affinity: ''
    alias: ''
    ant0: ''
    ant1: ''
    ant10: ''
    ant11: ''
    ant12: ''
    ant13: ''
    ant14: ''
    ant15: ''
    ant16: ''
    ant17: ''
    ant18: ''
    ant19: ''
    ant2: ''
    ant20: ''
    ant21: ''
    ant22: ''
    ant23: ''
    ant24: ''
    ant25: ''
    ant26: ''
    ant27: ''
    ant28: ''
    ant29: ''
    ant3: ''
    ant30: ''
    ant31: ''
    ant4: ''
    ant5: ''
    ant6: ''
    ant7: ''
    ant8: ''
    ant9: ''
    args: '""'
    bb_gain0: '20'
    bb_gain1: '20'
    bb_gain10: '20'
    bb_gain11: '20'
    bb_gain12: '20'
    bb_gain13: '20'
    bb_gain14: '20'
    bb_gain15: '20'
    bb_gain16: '20'
    bb_gain17: '20'
    bb_gain18: '20'
    bb_gain19: '20'
    bb_gain2: '20'
    bb_gain20: '20'
    bb_gain21: '20'
    bb_gain22: '20'
    bb_gain23: '20'
    bb_gain24: '20'
    bb_gain25: '20'
    bb_gain26: '20'
    bb_gain27: '20'
    bb_gain28: '20'
    bb_gain29: '20'
    bb_gain3: '20'
    bb_gain30: '20'
    bb_gain31: '20'
    bb_gain4: '20'
    bb_gain5: '20'
    bb_gain6: '20'
    bb_gain7: '20'
    bb_gain8: '20'
    bb_gain9: '20'
    bw0: '0'
    bw1: '0'
    bw10: '0'
    bw11: '0'
    bw12: '0'
    bw13: '0'
    bw14: '0'
    bw15: '0'
    bw16: '0'
    bw17: '0'
    bw18: '0'
    bw19: '0'
    bw2: '0'
    bw20: '0'
    bw21: '0'
    bw22: '0'
    bw23: '0'
    bw24: '0'
    bw25: '0'
    bw26: '0'
    bw27: '0'
    bw28: '0'
    bw29: '0'
    bw3: '0'
    bw30: '0'
    bw31: '0'
    bw4: '0'
    bw5: '0'
    bw6: '0'
    bw7: '0'
    bw8: '0'
    bw9: '0'
    clock_source0: ''
    clock_source1: ''
    clock_source2: ''
    clock_source3: ''
    clock_source4: ''
    clock_source5: ''
    clock_source6: ''
    clock_source7: ''
    comment: ''
    corr0: '0'
    corr1: '0'
    corr10: '0'
    corr11: '0'
    corr12: '0'
    corr13: '0'
    corr14: '0'
    corr15: '0'
    corr16: '0'
    corr17: '0'
    corr18: '0'
    corr19: '0'
    corr2: '0'
    corr20: '0'
    corr21: '0'
    corr22: '0'
    corr23: '0'
    corr24: '0'
    corr25: '0'
    corr26: '0'
    corr27: '0'
    corr28: '0'
    corr29: '0'
    corr3: '0'
    corr30: '0'
    corr31: '0'
    corr4: '0'
    corr5: '0'
    corr6: '0'
    corr7: '0'
    corr8: '0'
    corr9: '0'
    freq0: 100e6
    freq1: 100e6
    freq10: 100e6
    freq11: 100e6
    freq12: 100e6
    freq13: 100e6
    freq14: 100e6
    freq15: 100e6
    freq16: 100e6
    freq17: 100e6
    freq18: 100e6
    freq19: 100e6
    freq2: 100e6
    freq20: 100e6
    freq21: 100e6
    freq22: 100e6
    freq23: 100e6
    freq24: 100e6
    freq25: 100e6
    freq26: 100e6
    freq27: 100e6
    freq28: 100e6
    freq29: 100e6
    freq3: 100e6
    freq30: 100e6
    freq31: 100e6
    freq4: 100e6
    freq5: 100e6
    freq6: 100e6
    freq7: 100e6
    freq8: 100e6
    freq9: 100e6
    gain0: '10'
    gain1: '10'
    gain10: '10'
    gain11: '10'
    gain12: '10'
    gain13: '10'
    gain14: '10'
    gain15: '10'
    gain16: '10'
    gain17: '10'
    gain18: '10'
    gain19: '10'
    gain2: '10'
    gain20: '10'
    gain21: '10'
    gain22: '10'
    gain23: '10'
    gain24: '10'
    gain25: '10'
    gain26: '10'
    gain27: '10'
    gain28: '10'
    gain29: '10'
    gain3: '10'
    gain30: '10'
    gain31: '10'
    gain4: '10'
    gain5: '10'
    gain6: '10'
    gain7: '10'
    gain8: '10'
    gain9: '10'
    if_gain0: '20'
    if_gain1: '20'
    if_gain10: '20'
    if_gain11: '20'
    if_gain12: '20'
    if_gain13: '20'
    if_gain14: '20'
    if_gain15: '20'
    if_gain16: '20'
    if_gain17: '20'
    if_gain18: '20'
    if_gain19: '20'
    if_gain2: '20'
    if_gain20: '20'
    if_gain21: '20'
    if_gain22: '20'
    if_gain23: '20'
    if_gain24: '20'
    if_gain25: '20'
    if_gain26: '20'
    if_gain27: '20'
    if_gain28: '20'
    if_gain29: '20'
    if_gain3: '20'
    if_gain30: '20'
    if_gain31: '20'
    if_gain4: '20'
    if_gain5: '20'
    if_gain6: '20'
    if_gain7: '20'
    if_gain8: '20'
    if_gain9: '20'
    maxoutbuf: '0'
    minoutbuf: '0'
    nchan: '1'
    num_mboards: '1'
    sample_rate: samp_rate
    sync: sync
    time_source0: ''
    time_source1: ''
    time_source2: ''
    time_source3: ''
    time_source4: ''
    time_source5: ''
    time_source6: ''
    time_source7: ''
    type: fc32
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1336, 572.0]
    rotation: 0
    state: disabled
- name: qtgui_const_sink_x_0
  id: qtgui_const_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: '"blue"'
    color10: '"red"'
    color2: '"red"'
    color3: '"red"'
    color4: '"red"'
    color5: '"red"'
    color6: '"red"'
    color7: '"red"'
    color8: '"red"'
    color9: '"red"'
    comment: ''
    grid: 'False'
    gui_hint: ''
    label1: ''
    label10: ''
    label2: ''
    label3: ''
    label4: ''
    label5: ''
    label6: ''
    label7: ''
    label8: ''
    label9: ''
    legend: 'True'
    marker1: '0'
    marker10: '0'
    marker2: '0'
    marker3: '0'
    marker4: '0'
    marker5: '0'
    marker6: '0'
    marker7: '0'
    marker8: '0'
    marker9: '0'
    name: '""'
    nconnections: '1'
    size: '4096'
    style1: '0'
    style10: '0'
    style2: '0'
    style3: '0'
    style4: '0'
    style5: '0'
    style6: '0'
    style7: '0'
    style8: '0'
    style9: '0'
    tr_chan: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    xmax: '2'
    xmin: '-2'
    ymax: '2'
    ymin: '-2'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1160, 60.0]
    rotation: 0
    state: disabled
- name: qtgui_freq_sink_x_0
  id: qtgui_freq_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'True'
    average: '1.0'
    axislabels: 'True'
    bw: samp_rate
    color1: '"blue"'
    color10: '"dark blue"'
    color2: '"red"'
    color3: '"green"'
    color4: '"black"'
    color5: '"cyan"'
    color6: '"magenta"'
    color7: '"yellow"'
    color8: '"dark red"'
    color9: '"dark green"'
    comment: ''
    ctrlpanel: 'False'
    fc: 157.225e6
    fftsize: '1024'
    freqhalf: 'True'
    grid: 'True'
    gui_hint: ''
    label: Relative Gain
    label1: ''
    label10: ''''''
    label2: ''''''
    label3: ''''''
    label4: ''''''
    label5: ''''''
    label6: ''''''
    label7: ''''''
    label8: ''''''
    label9: ''''''
    legend: 'True'
    maxoutbuf: '0'
    minoutbuf: '0'
    name: '""'
    nconnections: '1'
    showports: 'False'
    tr_chan: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_tag: '""'
    type: complex
    units: dB
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    wintype: firdes.WIN_BLACKMAN_hARRIS
    ymax: '10'
    ymin: '-140'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1352, 364.0]
    rotation: 0
    state: enabled
- name: qtgui_time_sink_x_0
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: ''
    label1: Signal 1
    label10: Signal 10
    label2: Signal 2
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '""'
    nconnections: '1'
    size: '1024'
    srate: samp_rate
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1'
    ymin: '-1'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1392, 60.0]
    rotation: 0
    state: disabled
- name: qtgui_time_sink_x_1
  id: qtgui_time_sink_x
  parameters:
    affinity: ''
    alias: ''
    alpha1: '1.0'
    alpha10: '1.0'
    alpha2: '1.0'
    alpha3: '1.0'
    alpha4: '1.0'
    alpha5: '1.0'
    alpha6: '1.0'
    alpha7: '1.0'
    alpha8: '1.0'
    alpha9: '1.0'
    autoscale: 'False'
    axislabels: 'True'
    color1: blue
    color10: dark blue
    color2: red
    color3: green
    color4: black
    color5: cyan
    color6: magenta
    color7: yellow
    color8: dark red
    color9: dark green
    comment: ''
    ctrlpanel: 'False'
    entags: 'True'
    grid: 'False'
    gui_hint: ''
    label1: Signal 1
    label10: Signal 10
    label2: Signal 2
    label3: Signal 3
    label4: Signal 4
    label5: Signal 5
    label6: Signal 6
    label7: Signal 7
    label8: Signal 8
    label9: Signal 9
    legend: 'True'
    marker1: '-1'
    marker10: '-1'
    marker2: '-1'
    marker3: '-1'
    marker4: '-1'
    marker5: '-1'
    marker6: '-1'
    marker7: '-1'
    marker8: '-1'
    marker9: '-1'
    name: '""'
    nconnections: '1'
    size: '1024'
    srate: samp_rate
    stemplot: 'False'
    style1: '1'
    style10: '1'
    style2: '1'
    style3: '1'
    style4: '1'
    style5: '1'
    style6: '1'
    style7: '1'
    style8: '1'
    style9: '1'
    tr_chan: '0'
    tr_delay: '0'
    tr_level: '0.0'
    tr_mode: qtgui.TRIG_MODE_FREE
    tr_slope: qtgui.TRIG_SLOPE_POS
    tr_tag: '""'
    type: complex
    update_time: '0.10'
    width1: '1'
    width10: '1'
    width2: '1'
    width3: '1'
    width4: '1'
    width5: '1'
    width6: '1'
    width7: '1'
    width8: '1'
    width9: '1'
    ylabel: Amplitude
    ymax: '1'
    ymin: '-1'
    yunit: '""'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1224, 188.0]
    rotation: 0
    state: true

connections:
- [analog_sig_source_x_0, '0', blocks_multiply_xx_0, '1']
- [analog_sig_source_x_0_0, '0', blocks_multiply_xx_0_2, '1']
- [blocks_multiply_const_xx_0, '0', blocks_selector_0, '0']
- [blocks_multiply_const_xx_0, '0', osmosdr_sink_0, '0']
- [blocks_multiply_const_xx_0, '0', qtgui_freq_sink_x_0, '0']
- [blocks_multiply_const_xx_0_0, '0', blocks_selector_0, '1']
- [blocks_multiply_xx_0, '0', blocks_multiply_const_xx_0, '0']
- [blocks_multiply_xx_0_2, '0', blocks_multiply_const_xx_0_0, '0']
- [blocks_selector_0, '0', qtgui_freq_sink_x_0, '0']
- [blocks_throttle_0, '0', qtgui_const_sink_x_0, '0']
- [blocks_throttle_0, '0', qtgui_time_sink_x_1, '0']
- [digital_constellation_modulator_0, '0', blocks_multiply_xx_0, '0']
- [digital_constellation_modulator_0, '0', blocks_multiply_xx_0_2, '0']
- [digital_constellation_modulator_0, '0', blocks_throttle_0, '0']
- [digital_constellation_modulator_0, '0', epy_block_2, '0']
- [epy_block_0, '0', digital_constellation_modulator_0, '0']
- [epy_block_0, '0', epy_block_1, '0']

metadata:
  file_format: 1